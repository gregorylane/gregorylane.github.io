if (any(c <= 0)) {
return(rep(-1e9, length(c)))
}
if (r == 1) {
return(log(c))   # log utility if r == 1
} else {
return((c^(1 - r) - 1) / (1 - r))
}
}
# Logistic-based productivity factor z(epsilon)
z_of_epsilon <- function(eps, k) {
denom <- 1 + exp(-eps / k)
#(1 / (4 * k)) * exp(-eps / k) * (1 / denom^2)
1-1/denom
}
# Cobb-Douglas production function with logistic factor
f_prod <- function(x, eps, alpha, z_bar, k) {
if (x < 0) return(rep(0, length(eps)))
z_bar * z_of_epsilon(eps, k) * x^alpha
}
# Build a discrete normal-based probability distribution over eps_vals
make_prob <- function(eps_vals, mu, sigma) {
raw_probs <- dnorm(eps_vals, mean = mu, sd = sigma)
raw_probs / sum(raw_probs)
}
##############################################
# 2. NEGATIVE EXPECTED UTILITY
##############################################
neg_expected_utility <- function(x,
eps_vals,
mu_p, sigma_p,
alpha, z_bar, k,
r, beta,
y, p)
{
# Probability distribution according to (mu_p, sigma_p)
probs <- make_prob(eps_vals, mu_p, sigma_p)
c1 <- y - p*x
if (c1 <= 0) {
return(1e9)  # penalty if c1 <= 0
}
U1 <- u_crra(c1, r)
c2 <- f_prod(x, eps_vals, alpha, z_bar, k)
U2 <- u_crra(c2, r)
EU <- U1 + beta * sum(U2 * probs)
return(-EU)  # negative for 'minimize'
}
##############################################
# 3. GET OPTIMAL INVESTMENT (SINGLE CALL)
##############################################
get_optimal_x <- function(mu_p, sigma_p,
eps_vals,
alpha, z_bar, k,
r, beta,
y, p,
x_lower = -10, x_upper = 10) {
res <- optimize(
f = neg_expected_utility,
interval = c(x_lower, x_upper),
eps_vals = eps_vals,
mu_p = mu_p, sigma_p = sigma_p,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
res$minimum
}
##############################################
# 4. EXAMPLE: TRUE DISTRIBUTION + BIASED BELIEFS
##############################################
# 4a. Model parameters
r      <- 0.5   # risk aversion
beta   <- 0.95
y      <- 5
p      <- 1
alpha  <- 0.6
z_bar  <- 3
k      <- 2
# True distribution of epsilon
mu_true    <- 0
sigma_true <- 2
# Range of eps for discretization
eps_vals <- seq(-10, 10, by=0.5)
# 4b. Get the correct-belief optimum
x_opt_true <- get_optimal_x(
mu_p = mu_true,
sigma_p = sigma_true,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
cat("Optimal x (correct beliefs) =", x_opt_true, "\n")
# 4c. Define grid of biased beliefs
mu_biased_seq    <- seq(-5, 5, by=0.1)  # around the true mu=0
sigma_biased_seq <- seq(0.1, 4, by=0.1)   # around the true sigma=2
# We'll build a data.frame of all combos
df_biased <- expand.grid(
mu_p = mu_biased_seq,
sigma_p = sigma_biased_seq
)
# 4d. For each biased pair, find x_opt_biased, compute delta_x
df_biased$x_opt_biased <- NA_real_
for (i in seq_len(nrow(df_biased))) {
mb <- df_biased$mu_p[i]
sb <- df_biased$sigma_p[i]
# find the optimum given the biased beliefs
x_biased <- get_optimal_x(
mu_p = mb, sigma_p = sb,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
df_biased$x_opt_biased[i] <- x_biased
}
# 4e. Compute difference from correct optimum
df_biased$delta_x <- df_biased$x_opt_biased - x_opt_true
df_biased$delta_mu <- df_biased$mu_p - mu_true
df_biased$delta_sigma <- df_biased$sigma_p - sigma_true
df_biased$delta_x_pct <- df_biased$delta_x / x_opt_true * 100
# Inspect results
df_biased
##############################################
# 5. PLOT: Heat Map of delta_x
##############################################
library(ggplot2)
df_biased_mufixed <- filter(df_biased, delta_mu == 0)
df_biased_sigmafixed <- filter(df_biased, delta_sigma == 0)
ggplot(df_biased_sigmafixed, aes(y = x_opt_biased, x = delta_mu)) +
geom_line()
ggplot(df_biased_mufixed, aes(y = x_opt_biased, x = delta_sigma)) +
geom_line()
ggplot(df_biased, aes(x = delta_mu, y = delta_sigma, fill = delta_x_pct)) +
geom_tile(color = "white") +
scale_fill_gradient2(midpoint = 0, low="blue", mid="white", high="green") +
labs(
title = "Investment change under biased beliefs",
x = "Belief vs. truth (mean)",
y = "Belief vs. truth (SD)",
fill = expression(Delta~" inputs %")
) +
theme_minimal(base_size = 14)
# 4a. Model parameters
r      <- 0.5   # risk aversion
beta   <- 0.99
y      <- 5
p      <- 1
alpha  <- 0.6
z_bar  <- 3
k      <- 2
# True distribution of epsilon
mu_true    <- 0
sigma_true <- 2
# Range of eps for discretization
eps_vals <- seq(-10, 10, by=0.5)
# 4b. Get the correct-belief optimum
x_opt_true <- get_optimal_x(
mu_p = mu_true,
sigma_p = sigma_true,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
cat("Optimal x (correct beliefs) =", x_opt_true, "\n")
# 4c. Define grid of biased beliefs
mu_biased_seq    <- seq(-5, 5, by=0.1)  # around the true mu=0
sigma_biased_seq <- seq(0.1, 4, by=0.1)   # around the true sigma=2
# We'll build a data.frame of all combos
df_biased <- expand.grid(
mu_p = mu_biased_seq,
sigma_p = sigma_biased_seq
)
# 4d. For each biased pair, find x_opt_biased, compute delta_x
df_biased$x_opt_biased <- NA_real_
for (i in seq_len(nrow(df_biased))) {
mb <- df_biased$mu_p[i]
sb <- df_biased$sigma_p[i]
# find the optimum given the biased beliefs
x_biased <- get_optimal_x(
mu_p = mb, sigma_p = sb,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
df_biased$x_opt_biased[i] <- x_biased
}
# 4e. Compute difference from correct optimum
df_biased$delta_x <- df_biased$x_opt_biased - x_opt_true
df_biased$delta_mu <- df_biased$mu_p - mu_true
df_biased$delta_sigma <- df_biased$sigma_p - sigma_true
df_biased$delta_x_pct <- df_biased$delta_x / x_opt_true * 100
# Inspect results
df_biased
##############################################
# 5. PLOT: Heat Map of delta_x
##############################################
library(ggplot2)
df_biased_mufixed <- filter(df_biased, delta_mu == 0)
df_biased_sigmafixed <- filter(df_biased, delta_sigma == 0)
ggplot(df_biased_sigmafixed, aes(y = x_opt_biased, x = delta_mu)) +
geom_line()
ggplot(df_biased_mufixed, aes(y = x_opt_biased, x = delta_sigma)) +
geom_line()
ggplot(df_biased, aes(x = delta_mu, y = delta_sigma, fill = delta_x_pct)) +
geom_tile(color = "white") +
scale_fill_gradient2(midpoint = 0, low="blue", mid="white", high="green") +
labs(
title = "Investment change under biased beliefs",
x = "Belief vs. truth (mean)",
y = "Belief vs. truth (SD)",
fill = expression(Delta~" inputs %")
) +
theme_minimal(base_size = 14)
# 4a. Model parameters
r      <- 0.5   # risk aversion
beta   <- 0.95
y      <- 5
p      <- 1
alpha  <- 0.2
z_bar  <- 3
k      <- 2
# True distribution of epsilon
mu_true    <- 0
sigma_true <- 2
# Range of eps for discretization
eps_vals <- seq(-10, 10, by=0.5)
# 4b. Get the correct-belief optimum
x_opt_true <- get_optimal_x(
mu_p = mu_true,
sigma_p = sigma_true,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
cat("Optimal x (correct beliefs) =", x_opt_true, "\n")
# 4c. Define grid of biased beliefs
mu_biased_seq    <- seq(-5, 5, by=0.1)  # around the true mu=0
sigma_biased_seq <- seq(0.1, 4, by=0.1)   # around the true sigma=2
# We'll build a data.frame of all combos
df_biased <- expand.grid(
mu_p = mu_biased_seq,
sigma_p = sigma_biased_seq
)
# 4d. For each biased pair, find x_opt_biased, compute delta_x
df_biased$x_opt_biased <- NA_real_
for (i in seq_len(nrow(df_biased))) {
mb <- df_biased$mu_p[i]
sb <- df_biased$sigma_p[i]
# find the optimum given the biased beliefs
x_biased <- get_optimal_x(
mu_p = mb, sigma_p = sb,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
df_biased$x_opt_biased[i] <- x_biased
}
# 4e. Compute difference from correct optimum
df_biased$delta_x <- df_biased$x_opt_biased - x_opt_true
df_biased$delta_mu <- df_biased$mu_p - mu_true
df_biased$delta_sigma <- df_biased$sigma_p - sigma_true
df_biased$delta_x_pct <- df_biased$delta_x / x_opt_true * 100
# Inspect results
df_biased
##############################################
# 5. PLOT: Heat Map of delta_x
##############################################
library(ggplot2)
df_biased_mufixed <- filter(df_biased, delta_mu == 0)
df_biased_sigmafixed <- filter(df_biased, delta_sigma == 0)
ggplot(df_biased_sigmafixed, aes(y = x_opt_biased, x = delta_mu)) +
geom_line()
ggplot(df_biased_mufixed, aes(y = x_opt_biased, x = delta_sigma)) +
geom_line()
ggplot(df_biased, aes(x = delta_mu, y = delta_sigma, fill = delta_x_pct)) +
geom_tile(color = "white") +
scale_fill_gradient2(midpoint = 0, low="blue", mid="white", high="green") +
labs(
title = "Investment change under biased beliefs",
x = "Belief vs. truth (mean)",
y = "Belief vs. truth (SD)",
fill = expression(Delta~" inputs %")
) +
theme_minimal(base_size = 14)
# 4a. Model parameters
r      <- 0.5   # risk aversion
beta   <- 0.95
y      <- 5
p      <- 1
alpha  <- 0.6
z_bar  <- 1
k      <- 2
# True distribution of epsilon
mu_true    <- 0
sigma_true <- 2
# Range of eps for discretization
eps_vals <- seq(-10, 10, by=0.5)
# 4b. Get the correct-belief optimum
x_opt_true <- get_optimal_x(
mu_p = mu_true,
sigma_p = sigma_true,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
cat("Optimal x (correct beliefs) =", x_opt_true, "\n")
# 4c. Define grid of biased beliefs
mu_biased_seq    <- seq(-5, 5, by=0.1)  # around the true mu=0
sigma_biased_seq <- seq(0.1, 4, by=0.1)   # around the true sigma=2
# We'll build a data.frame of all combos
df_biased <- expand.grid(
mu_p = mu_biased_seq,
sigma_p = sigma_biased_seq
)
# 4d. For each biased pair, find x_opt_biased, compute delta_x
df_biased$x_opt_biased <- NA_real_
for (i in seq_len(nrow(df_biased))) {
mb <- df_biased$mu_p[i]
sb <- df_biased$sigma_p[i]
# find the optimum given the biased beliefs
x_biased <- get_optimal_x(
mu_p = mb, sigma_p = sb,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
df_biased$x_opt_biased[i] <- x_biased
}
# 4e. Compute difference from correct optimum
df_biased$delta_x <- df_biased$x_opt_biased - x_opt_true
df_biased$delta_mu <- df_biased$mu_p - mu_true
df_biased$delta_sigma <- df_biased$sigma_p - sigma_true
df_biased$delta_x_pct <- df_biased$delta_x / x_opt_true * 100
# Inspect results
df_biased
##############################################
# 5. PLOT: Heat Map of delta_x
##############################################
library(ggplot2)
df_biased_mufixed <- filter(df_biased, delta_mu == 0)
df_biased_sigmafixed <- filter(df_biased, delta_sigma == 0)
ggplot(df_biased_sigmafixed, aes(y = x_opt_biased, x = delta_mu)) +
geom_line()
ggplot(df_biased_mufixed, aes(y = x_opt_biased, x = delta_sigma)) +
geom_line()
ggplot(df_biased, aes(x = delta_mu, y = delta_sigma, fill = delta_x_pct)) +
geom_tile(color = "white") +
scale_fill_gradient2(midpoint = 0, low="blue", mid="white", high="green") +
labs(
title = "Investment change under biased beliefs",
x = "Belief vs. truth (mean)",
y = "Belief vs. truth (SD)",
fill = expression(Delta~" inputs %")
) +
theme_minimal(base_size = 14)
# 4a. Model parameters
r      <- 0.8   # risk aversion
beta   <- 0.95
y      <- 5
p      <- 1
alpha  <- 0.6
z_bar  <- 1
k      <- 2
# True distribution of epsilon
mu_true    <- 0
sigma_true <- 2
# Range of eps for discretization
eps_vals <- seq(-10, 10, by=0.5)
# 4b. Get the correct-belief optimum
x_opt_true <- get_optimal_x(
mu_p = mu_true,
sigma_p = sigma_true,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
cat("Optimal x (correct beliefs) =", x_opt_true, "\n")
# 4c. Define grid of biased beliefs
mu_biased_seq    <- seq(-5, 5, by=0.1)  # around the true mu=0
sigma_biased_seq <- seq(0.1, 4, by=0.1)   # around the true sigma=2
# We'll build a data.frame of all combos
df_biased <- expand.grid(
mu_p = mu_biased_seq,
sigma_p = sigma_biased_seq
)
# 4d. For each biased pair, find x_opt_biased, compute delta_x
df_biased$x_opt_biased <- NA_real_
for (i in seq_len(nrow(df_biased))) {
mb <- df_biased$mu_p[i]
sb <- df_biased$sigma_p[i]
# find the optimum given the biased beliefs
x_biased <- get_optimal_x(
mu_p = mb, sigma_p = sb,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
df_biased$x_opt_biased[i] <- x_biased
}
# 4e. Compute difference from correct optimum
df_biased$delta_x <- df_biased$x_opt_biased - x_opt_true
df_biased$delta_mu <- df_biased$mu_p - mu_true
df_biased$delta_sigma <- df_biased$sigma_p - sigma_true
df_biased$delta_x_pct <- df_biased$delta_x / x_opt_true * 100
# Inspect results
df_biased
##############################################
# 5. PLOT: Heat Map of delta_x
##############################################
library(ggplot2)
df_biased_mufixed <- filter(df_biased, delta_mu == 0)
df_biased_sigmafixed <- filter(df_biased, delta_sigma == 0)
ggplot(df_biased_sigmafixed, aes(y = x_opt_biased, x = delta_mu)) +
geom_line()
ggplot(df_biased_mufixed, aes(y = x_opt_biased, x = delta_sigma)) +
geom_line()
ggplot(df_biased, aes(x = delta_mu, y = delta_sigma, fill = delta_x_pct)) +
geom_tile(color = "white") +
scale_fill_gradient2(midpoint = 0, low="blue", mid="white", high="green") +
labs(
title = "Investment change under biased beliefs",
x = "Belief vs. truth (mean)",
y = "Belief vs. truth (SD)",
fill = expression(Delta~" inputs %")
) +
theme_minimal(base_size = 14)
# 4a. Model parameters
r      <- 0.8   # risk aversion
beta   <- 0.95
y      <- 5
p      <- 1
alpha  <- 0.6
z_bar  <- 3
k      <- 2
# True distribution of epsilon
mu_true    <- 0
sigma_true <- 2
# Range of eps for discretization
eps_vals <- seq(-10, 10, by=0.5)
# 4b. Get the correct-belief optimum
x_opt_true <- get_optimal_x(
mu_p = mu_true,
sigma_p = sigma_true,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
cat("Optimal x (correct beliefs) =", x_opt_true, "\n")
# 4c. Define grid of biased beliefs
mu_biased_seq    <- seq(-2, 2, by=0.1)  # around the true mu=0
sigma_biased_seq <- seq(0.1, 4, by=0.1)   # around the true sigma=2
# We'll build a data.frame of all combos
df_biased <- expand.grid(
mu_p = mu_biased_seq,
sigma_p = sigma_biased_seq
)
# 4d. For each biased pair, find x_opt_biased, compute delta_x
df_biased$x_opt_biased <- NA_real_
for (i in seq_len(nrow(df_biased))) {
mb <- df_biased$mu_p[i]
sb <- df_biased$sigma_p[i]
# find the optimum given the biased beliefs
x_biased <- get_optimal_x(
mu_p = mb, sigma_p = sb,
eps_vals = eps_vals,
alpha = alpha, z_bar = z_bar, k = k,
r = r, beta = beta,
y = y, p = p
)
df_biased$x_opt_biased[i] <- x_biased
}
# 4e. Compute difference from correct optimum
df_biased$delta_x <- df_biased$x_opt_biased - x_opt_true
df_biased$delta_mu <- df_biased$mu_p - mu_true
df_biased$delta_sigma <- df_biased$sigma_p - sigma_true
df_biased$delta_x_pct <- df_biased$delta_x / x_opt_true * 100
# Inspect results
df_biased
##############################################
# 5. PLOT: Heat Map of delta_x
##############################################
library(ggplot2)
df_biased_mufixed <- filter(df_biased, delta_mu == 0)
df_biased_sigmafixed <- filter(df_biased, delta_sigma == 0)
ggplot(df_biased_sigmafixed, aes(y = x_opt_biased, x = delta_mu)) +
geom_line()
ggplot(df_biased_mufixed, aes(y = x_opt_biased, x = delta_sigma)) +
geom_line()
ggplot(df_biased, aes(x = delta_mu, y = delta_sigma, fill = delta_x_pct)) +
geom_tile(color = "white") +
scale_fill_gradient2(midpoint = 0, low="blue", mid="white", high="green") +
labs(
title = "Investment change under biased beliefs",
x = "Belief vs. truth (mean)",
y = "Belief vs. truth (SD)",
fill = expression(Delta~" inputs %")
) +
theme_minimal(base_size = 14)
setwd("~/Documents/Website/gregorylane.github.io")
rmarkdown::render_site()
rmarkdown::render_site()
rmarkdown::render_site()
