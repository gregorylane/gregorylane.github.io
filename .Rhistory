std <- as.numeric(fg$estimate[2]) #pul std from estimated distribution
#Starting choice of target and value of contract for fixed point algorithm
g_u <- 50 #need some fixed value of U for input in recursive problem
max_target = delta*g_u #calc max_target possible given the first guess of U
g_target <- min(40, max_target) #choose target, but don't allow choice above max transfer compatible T
g_v <- 40 #need some first guess fo V
g_welfare <- g_u + g_v
#Write everything as a function of the target, initial U choice and primitives
output <- function(inputs){
target <-inputs[1]
u_fix <-inputs[3]
v_fix <- inputs[4]
alpha <- (target - mean)/std #how many std. devs the target is above / below mean
intercept <- max(1 - (target)/(delta*u_fix),0) # define p_0
#Formulas for expected value of y from a normal distribution found in Greene Chapter 19
exp_y_below <- mean(surplus$surplus[surplus <= target], na.rm=T)
exp_y_above <- mean(surplus$surplus[surplus >= target], na.rm=T)
#Formula of expected continutation probability
continue_prob = plogis(target, mean, std)*(intercept + (1/(delta*u_fix))*exp_y_below)+(1-plogis(target, mean, std))
U <- ((1-plogis(target, mean, std))*(exp_y_above - target)-work_cost+
(1 - continue_prob)*delta*outside_option)/(1-delta)
#Re-Calc max target possible to limit search function
max_target2 = delta*U
V <-  (target - plogis(target, mean, std)*(1+(v_fix/U))*(target - exp_y_below) - exp_cost -
(1 - continue_prob)*delta*h)/(1 - delta) #Calc Value of contract for owner
#find target that maximizes the owner payoff given all the above
xmin <- qlogis(0.1, mean, std) #Note, for some parameter values, too low a target search leads to NAs which breaks system, change this if optim fails
xmax <- qlogis(0.6, mean, std)
own_payoff <- function(target, u) {
payoff <- delta*V + target - exp_cost - plogis(target, mean, std)*(1+V/U)*(target - exp_y_below)
}
tar <- optimize(own_payoff, interval=c(xmin, xmax), maximum=TRUE, u=U)$maximum
#Calculate owner payoff, driver payoff, and calc max target that driver will agree to (i.e. see if optimal owner target is outside of participation constraint)
own_payoff <- optimize(own_payoff, interval=c(xmin, max_target2), maximum=TRUE, u=U)$objective
dri_payoff <- delta*U - tar + mean - work_cost
min_agree_tar <- delta*U -dri_payoff + mean - work_cost
#Recalc target and payoffs now that see if at boundry
tar = min(tar, min_agree_tar)
own_payoff <- delta*V + tar - exp_cost - plogis(tar, mean, std)*(1+V/U)*(tar - exp_y_below)
profits <- tar - exp_cost - plogis(tar, mean, std)*(tar - exp_y_below)
exp_salary <- (1-plogis(target, mean, std))*(exp_y_above-target)
exp_income <- tar - plogis(tar, mean, std)*(tar - exp_y_below)
welfare <- U + V
return(c(tar, max_target2, U, V, continue_prob, profits, intercept, exp_salary, exp_income, welfare))
}
inputs <- c(g_target, 40, g_u, g_v, 0.9, 10, 0.9, 8, 10, g_welfare) #Give inputs for target, max target, Driver U, owner_payoff,  driver_payoff, and continue prob
values <- FixedPoint(Function = output, Inputs = inputs, Method = "Anderson", MaxIter = 10000)
end_target <- values$FixedPoint[1]
max_target_chosen <- round(values$FixedPoint[1],0.1) == round(values$FixedPoint[2], 0.1)
end_U <- values$FixedPoint[3]
end_V <- values$FixedPoint[4]
end_ep <- values$FixedPoint[5]
end_exp_profits <- values$FixedPoint[6]
end_intercept <- values$FixedPoint[7]
end_exp_salary <- values$FixedPoint[8]
end_exp_income <- values$FixedPoint[9]
end_welfare <- values$FixedPoint[10]
results <- c(end_target, end_U, end_V, end_ep, end_exp_profits, end_intercept, end_exp_salary, end_exp_income, end_welfare)
return(results)
}
#Choose parameters
exp_cost <- 4.9 # in data average is 4.9 in control group, expected repairs costs at e* r* which are fixed by mean, std, of Y and independent of T, U
delta <- 0.99 #discount factor
work_cost <- 3 # cost of effort + risk for driver which are independent of T, U - note: average G_e seems to be around 250, so seems reasonable that total cost is around that?
h <- 160 #rehiring / firing cost for owner - put this at about 1 week profits?
outside_option <- 8/(1-delta) #"Value of job is 289.59" which should be U minus outside option?
#Bootstrap results
outputs <- as.data.frame(t(sapply(1:200, boot_opt, treat=0)) )
names(outputs) <- c("target", "U", "V", "ep", "exp_profit", "intercept", "exp_salary", "exp_income",  "welfare")
results<-data.frame(estimate=c(mean(outputs$target, na.rm=T), mean(outputs$U, na.rm=T), mean(outputs$V, na.rm=T), mean(outputs$ep, na.rm=T), mean(outputs$exp_profit, na.rm=T), mean(outputs$exp_salary, na.rm=T), mean(outputs$welfare, na.rm=T)),
stderr = c(sd(outputs$target, na.rm=T),sd(outputs$U, na.rm=T), sd(outputs$V, na.rm=T), sd(outputs$ep, na.rm=T), sd(outputs$exp_profit, na.rm=T), sd(outputs$exp_salary, na.rm=T), sd(outputs$welfare, na.rm=T)))
results$names <- c("target", "U", "V","ep","exp_profit", "exp_salary", "welfare")
#Put results into table for export
options(scipen=99)
table <- data.frame(Outcome = c("Target", "", "Expected Profit", "","Expected Salary", "", "Prob. Separation", "",
"Driver Contract Value minus Outside Option", "", "Owner Value", "",
"Total Welfare", ""),
Prediction=c(round(mean(outputs$target, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs$target, na.rm=T), digits=2)),")"),
round(mean(outputs$exp_profit, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs$exp_profit, na.rm=T), digits=2)),")"),
round(mean(outputs$exp_salary, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs$exp_salary, na.rm=T), digits=2)),")"),
round(1- mean(outputs$ep, na.rm=T), digits=4), paste0("(", as.character(round(sd(1-outputs$ep, na.rm=T), digits=5)),")"),
round(mean(outputs$U, na.rm=T)-outside_option, digits=2), paste0("(", as.character(round(sd(outputs$U, na.rm=T), digits=2)),")"),
round(mean(outputs$V, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs$V, na.rm=T), digits=2)),")"),
round(mean(outputs$welfare, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs$welfare, na.rm=T), digits=2)),")"))
)
#Notes: low outside option for driver lowers the target and increases change of firing
#High firing costs increasers the target, doesn't change much else
#Increasing work cost lower target - makese U, V lower, everyone worse off
##########
#Change parameters for comparison after monitoring (220 (ish) Ksh drop in repair costs, work time up 10ish percent, so move 1 more work cost given convexity?)
exp_cost <- 2.7 # in data, 490 in control group, expected repairs costs at e* r* which are fixed by mean, std, of Y and independent of T, U
delta <- 0.99 #discount factor
work_cost <- 4.5 # cost of effort + risk for driver which are independent of T, U - note: average G_e seems to be around 250, so seems reasonable that total cost is around that?
h <- 160 #rehiring / firing cost for owner - put this at about 1 week profits?
outside_option <- 8/(1-delta) #"Value of job is 289.59" which should be U minus outside option?
outputs2 <- as.data.frame(t(sapply(1:200, boot_opt, treat=1)) )
names(outputs2) <- c("target", "U", "V", "ep", "exp_profit", "intercept", "exp_salary", "exp_income", "welfare")
results2<-data.frame(estimate=c(mean(outputs2$target, na.rm=T), mean(outputs2$U, na.rm=T), mean(outputs2$V, na.rm=T), mean(outputs2$ep, na.rm=T), mean(outputs2$exp_profit, na.rm=T), mean(outputs2$exp_salary, na.rm=T), mean(outputs2$welfare, na.rm=T)),
stderr = c(sd(outputs2$target, na.rm=T),sd(outputs2$U, na.rm=T), sd(outputs2$V, na.rm=T), sd(outputs2$ep, na.rm=T), sd(outputs2$exp_profit, na.rm=T), sd(output2s$exp_salary, na.rm=T), sd(outputs2$welfare, na.rm=T)))
results2$names <- c("target", "U", "V","ep","exp_profit", "exp_salary", "welfare")
table2 <- data.frame(Outcome = c("Target", "", "Expected Profit", "","Expected Salary", "", "Prob. Separation", "",
"Driver Value minus Outside Option", "", "Owner Value", "",
"Total Welfare", ""),
Prediction=c(round(mean(outputs2$target, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs2$target, na.rm=T), digits=2)),")"),
round(mean(outputs2$exp_profit, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs2$exp_profit, na.rm=T), digits=2)),")"),
round(mean(outputs2$exp_salary, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs2$exp_salary, na.rm=T), digits=2)),")"),
round(1-mean(outputs2$ep, na.rm=T), digits=4), paste0("(", as.character(round(sd(1-outputs2$ep, na.rm=T), digits=4)),")"),
round(mean(outputs2$U, na.rm=T)-outside_option, digits=2), paste0("(", as.character(round(sd(outputs2$U, na.rm=T), digits=2)),")"),
round(mean(outputs2$V, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs2$V, na.rm=T), digits=2)),")"),
round(mean(outputs2$welfare, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs2$welfare, na.rm=T), digits=2)),")"))
)
#######################################################################################
##################### Load in Survey Data and Create Tables ######################
#######################################################################################
#read data with actual outcomes
data_survey <- read.csv("~/Dropbox/Matatu/model/greg/sims/table_data2.csv") %>%
mutate(profit = income - repaircost/2) #try and account for some of repair costs already being baked in to income get correct mean levels
##Add Observed results to prediction table
#For baseline data, collapse down to did or pid where appropriate
data_survey_did <- data_survey %>% group_by(did) %>%
summarise(valueofjob=mean(valueofjob, na.rm=T))
#Reg daily outcomes on constant but cluster responses by pid, grab standard error for table
cluster_mean_stder <- function(var) {
reg <- felm(var ~ 1 | 0 | 0 | pid, data=data_survey)
cl_stder <- reg$cse
return(cl_stder)
}
temp <- as.data.frame(t(apply(data_survey, 2, FUN=cluster_mean_stder)))
survey_table <- data.frame(Observed=c(round(mean(data_survey$target, na.rm=T), digits=2), paste0("(", as.character(round(temp$target[1], digits=2)),")"),
round(mean(data_survey$profit, na.rm=T), digits=2), paste0("(", as.character(round(temp$profit[1], digits=2)),")"),
round(mean(data_survey$salary, na.rm=T), digits=2), paste0("(", as.character(round(temp$salary[1], digits=2)),")"),
round(mean(data_survey$separated_2, na.rm=T), digits=4), paste0("(", as.character(round(temp$separated_2[1], digits=4)),")"),
round(mean(data_survey_did$valueofjob, na.rm=T), digits=2), paste0("(", as.character(round(sd(data_survey_did$valueofjob, na.rm=T)/sqrt(nrow(data_survey_did)), digits=2)),")"),
"---", "",
"---", ""))
#Calc differences (with standard error)
diffs <- data.frame(Difference = c(
round(mean(outputs$target, na.rm=T)-mean(data_survey$target, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$target, na.rm=T)^2 + temp$target[1]^2),digits=2),")"),
round(mean(outputs$exp_profit, na.rm=T)-mean(data_survey$profit, na.rm=T), digits=3),
paste0("(",round(sqrt(sd(outputs$exp_profit, na.rm=T)^2 + temp$profit[1]^2),digits=2),")"),
round(mean(outputs$exp_salary, na.rm=T)-mean(data_survey$salary, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$exp_salary, na.rm=T)^2 + temp$salary[1]^2),digits=2),")"),
round(mean(1-outputs$ep, na.rm=T)-mean(data_survey$separated_2, na.rm=T), digits=4),
paste0("(",round(sqrt(sd(outputs$ep, na.rm=T)^2 + temp$separated_2[1]^2),digits=4),")"),
round(round(mean(outputs$U, na.rm=T)-outside_option, digits=2)-mean(data_survey_did$valueofjob, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$U, na.rm=T)^2 + (sd(data_survey_did$valueofjob, na.rm=T)/sqrt(nrow(data_survey_did)))^2),digits=2),")"),
"---",
"",
"---",
""
))
#Col bind for Status Quo Match
out_table <- bind_cols(table, survey_table, diffs)
options(huxtable.print = print_latex)
tbl <- hux(out_table)
tbl
tbl<- print.xtable(xtable(out_table,
caption=c("Prediction Results Versus Data"),
align=c("l","p{9cm}","c","c","c")),
include.rownames=FALSE,
caption.placement = getOption("xtable.caption.placement", "top"),
latex.environments = getOption("xtable.latex.environments", c("center")),
hline.after=c(-1,-1,0,nrow(table),nrow(table)),
add.to.row=list(pos=list(2,4,6,8,10,12), command=c("[.5em]","[.5em]","[.5em]","[.5em]","[.5em]","[.5em]"))
)
cat(tbl, sep = '\n', file="~/Dropbox/Matatu/model/greg/sims/tables/compare_table1.tex")
tbl<- print.xtable(xtable(out_table,
caption=c("Prediction Results Versus Data"),
align=c("l","p{9cm}","c","c","c")),
include.rownames=FALSE,
caption.placement = getOption("xtable.caption.placement", "top"),
latex.environments = getOption("xtable.latex.environments", c("center")),
hline.after=c(-1,-1,0,nrow(table),nrow(table)),
add.to.row=list(pos=list(2,4,6,8,10,12), command=c("[.5em]","[.5em]","[.5em]","[.5em]","[.5em]","[.5em]"))
)
rm(list = ls())
library(pacman)
p_load(data.table, tidyverse, magrittr, ggplot2, FixedPoint, fitdistrplus, stats, boot, gmm,
stargazer, xtable, lfe, huxtable)
set.seed(20200515)
#Using real surplus data
surplus <- read.csv("~/Dropbox/Matatu/model/greg/sims/surplus2.csv") %>%
mutate(surplus = ifelse(surplus < 10, surplus*100, surplus)) %>%
mutate(surplus = surplus/100-7) %>% #subtract off the subsistence constraint
mutate(surplus = ifelse(surplus < 0, NA, surplus)) %>%
na.omit
boot_opt <- function(x, treat) {
if(treat==1) {
surplus %<>% filter(treat==1)
}
if(treat==0) {
surplus %<>% filter(treat==0)
}
surplus <- as.data.frame(surplus$surplus)
sample <- sample_n(surplus, size=9504, replace=T)
fg <- fitdist(sample$surplus, distr="logis")
#plot(fg)
#Choose paramters
mean <- as.numeric(fg$estimate[1]) #pull mean from estimated distribution
std <- as.numeric(fg$estimate[2]) #pul std from estimated distribution
#Starting choice of target and value of contract for fixed point algorithm
g_u <- 50 #need some fixed value of U for input in recursive problem
max_target = delta*g_u #calc max_target possible given the first guess of U
g_target <- min(40, max_target) #choose target, but don't allow choice above max transfer compatible T
g_v <- 40 #need some first guess fo V
g_welfare <- g_u + g_v
#Write everything as a function of the target, initial U choice and primitives
output <- function(inputs){
target <-inputs[1]
u_fix <-inputs[3]
v_fix <- inputs[4]
alpha <- (target - mean)/std #how many std. devs the target is above / below mean
intercept <- max(1 - (target)/(delta*u_fix),0) # define p_0
#Formulas for expected value of y from a normal distribution found in Greene Chapter 19
exp_y_below <- mean(surplus$surplus[surplus <= target], na.rm=T)
exp_y_above <- mean(surplus$surplus[surplus >= target], na.rm=T)
#Formula of expected continutation probability
continue_prob = plogis(target, mean, std)*(intercept + (1/(delta*u_fix))*exp_y_below)+(1-plogis(target, mean, std))
U <- ((1-plogis(target, mean, std))*(exp_y_above - target)-work_cost+
(1 - continue_prob)*delta*outside_option)/(1-delta)
#Re-Calc max target possible to limit search function
max_target2 = delta*U
V <-  (target - plogis(target, mean, std)*(1+(v_fix/U))*(target - exp_y_below) - exp_cost -
(1 - continue_prob)*delta*h)/(1 - delta) #Calc Value of contract for owner
#find target that maximizes the owner payoff given all the above
xmin <- qlogis(0.1, mean, std) #Note, for some parameter values, too low a target search leads to NAs which breaks system, change this if optim fails
xmax <- qlogis(0.6, mean, std)
own_payoff <- function(target, u) {
payoff <- delta*V + target - exp_cost - plogis(target, mean, std)*(1+V/U)*(target - exp_y_below)
}
tar <- optimize(own_payoff, interval=c(xmin, xmax), maximum=TRUE, u=U)$maximum
#Calculate owner payoff, driver payoff, and calc max target that driver will agree to (i.e. see if optimal owner target is outside of participation constraint)
own_payoff <- optimize(own_payoff, interval=c(xmin, max_target2), maximum=TRUE, u=U)$objective
dri_payoff <- delta*U - tar + mean - work_cost
min_agree_tar <- delta*U -dri_payoff + mean - work_cost
#Recalc target and payoffs now that see if at boundry
tar = min(tar, min_agree_tar)
own_payoff <- delta*V + tar - exp_cost - plogis(tar, mean, std)*(1+V/U)*(tar - exp_y_below)
profits <- tar - exp_cost - plogis(tar, mean, std)*(tar - exp_y_below)
exp_salary <- (1-plogis(target, mean, std))*(exp_y_above-target)
exp_income <- tar - plogis(tar, mean, std)*(tar - exp_y_below)
welfare <- U + V
return(c(tar, max_target2, U, V, continue_prob, profits, intercept, exp_salary, exp_income, welfare))
}
inputs <- c(g_target, 40, g_u, g_v, 0.9, 10, 0.9, 8, 10, g_welfare) #Give inputs for target, max target, Driver U, owner_payoff,  driver_payoff, and continue prob
values <- FixedPoint(Function = output, Inputs = inputs, Method = "Anderson", MaxIter = 10000)
end_target <- values$FixedPoint[1]
max_target_chosen <- round(values$FixedPoint[1],0.1) == round(values$FixedPoint[2], 0.1)
end_U <- values$FixedPoint[3]
end_V <- values$FixedPoint[4]
end_ep <- values$FixedPoint[5]
end_exp_profits <- values$FixedPoint[6]
end_intercept <- values$FixedPoint[7]
end_exp_salary <- values$FixedPoint[8]
end_exp_income <- values$FixedPoint[9]
end_welfare <- values$FixedPoint[10]
results <- c(end_target, end_U, end_V, end_ep, end_exp_profits, end_intercept, end_exp_salary, end_exp_income, end_welfare)
return(results)
}
#Choose parameters
exp_cost <- 4.9 # in data average is 4.9 in control group, expected repairs costs at e* r* which are fixed by mean, std, of Y and independent of T, U
delta <- 0.99 #discount factor
work_cost <- 3 # cost of effort + risk for driver which are independent of T, U - note: average G_e seems to be around 250, so seems reasonable that total cost is around that?
h <- 160 #rehiring / firing cost for owner - put this at about 1 week profits?
outside_option <- 8/(1-delta) #"Value of job is 289.59" which should be U minus outside option?
#Bootstrap results
outputs <- as.data.frame(t(sapply(1:200, boot_opt, treat=0)) )
names(outputs) <- c("target", "U", "V", "ep", "exp_profit", "intercept", "exp_salary", "exp_income",  "welfare")
results<-data.frame(estimate=c(mean(outputs$target, na.rm=T), mean(outputs$U, na.rm=T), mean(outputs$V, na.rm=T), mean(outputs$ep, na.rm=T), mean(outputs$exp_profit, na.rm=T), mean(outputs$exp_salary, na.rm=T), mean(outputs$welfare, na.rm=T)),
stderr = c(sd(outputs$target, na.rm=T),sd(outputs$U, na.rm=T), sd(outputs$V, na.rm=T), sd(outputs$ep, na.rm=T), sd(outputs$exp_profit, na.rm=T), sd(outputs$exp_salary, na.rm=T), sd(outputs$welfare, na.rm=T)))
results$names <- c("target", "U", "V","ep","exp_profit", "exp_salary", "welfare")
#Put results into table for export
options(scipen=99)
table <- data.frame(Outcome = c("Target", "", "Expected Profit", "","Expected Salary", "", "Prob. Separation", "",
"Driver Contract Value minus Outside Option", "", "Owner Value", "",
"Total Welfare", ""),
Prediction=c(round(mean(outputs$target, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs$target, na.rm=T), digits=2)),")"),
round(mean(outputs$exp_profit, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs$exp_profit, na.rm=T), digits=2)),")"),
round(mean(outputs$exp_salary, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs$exp_salary, na.rm=T), digits=2)),")"),
round(1- mean(outputs$ep, na.rm=T), digits=4), paste0("(", as.character(round(sd(1-outputs$ep, na.rm=T), digits=5)),")"),
round(mean(outputs$U, na.rm=T)-outside_option, digits=2), paste0("(", as.character(round(sd(outputs$U, na.rm=T), digits=2)),")"),
round(mean(outputs$V, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs$V, na.rm=T), digits=2)),")"),
round(mean(outputs$welfare, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs$welfare, na.rm=T), digits=2)),")"))
)
#Notes: low outside option for driver lowers the target and increases change of firing
#High firing costs increasers the target, doesn't change much else
#Increasing work cost lower target - makese U, V lower, everyone worse off
##########
#Change parameters for comparison after monitoring (220 (ish) Ksh drop in repair costs, work time up 10ish percent, so move 1 more work cost given convexity?)
exp_cost <- 2.7 # in data, 490 in control group, expected repairs costs at e* r* which are fixed by mean, std, of Y and independent of T, U
delta <- 0.99 #discount factor
work_cost <- 4.5 # cost of effort + risk for driver which are independent of T, U - note: average G_e seems to be around 250, so seems reasonable that total cost is around that?
h <- 160 #rehiring / firing cost for owner - put this at about 1 week profits?
outside_option <- 8/(1-delta) #"Value of job is 289.59" which should be U minus outside option?
outputs2 <- as.data.frame(t(sapply(1:200, boot_opt, treat=1)) )
names(outputs2) <- c("target", "U", "V", "ep", "exp_profit", "intercept", "exp_salary", "exp_income", "welfare")
results2<-data.frame(estimate=c(mean(outputs2$target, na.rm=T), mean(outputs2$U, na.rm=T), mean(outputs2$V, na.rm=T), mean(outputs2$ep, na.rm=T), mean(outputs2$exp_profit, na.rm=T), mean(outputs2$exp_salary, na.rm=T), mean(outputs2$welfare, na.rm=T)),
stderr = c(sd(outputs2$target, na.rm=T),sd(outputs2$U, na.rm=T), sd(outputs2$V, na.rm=T), sd(outputs2$ep, na.rm=T), sd(outputs2$exp_profit, na.rm=T), sd(output2s$exp_salary, na.rm=T), sd(outputs2$welfare, na.rm=T)))
results2$names <- c("target", "U", "V","ep","exp_profit", "exp_salary", "welfare")
table2 <- data.frame(Outcome = c("Target", "", "Expected Profit", "","Expected Salary", "", "Prob. Separation", "",
"Driver Value minus Outside Option", "", "Owner Value", "",
"Total Welfare", ""),
Prediction=c(round(mean(outputs2$target, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs2$target, na.rm=T), digits=2)),")"),
round(mean(outputs2$exp_profit, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs2$exp_profit, na.rm=T), digits=2)),")"),
round(mean(outputs2$exp_salary, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs2$exp_salary, na.rm=T), digits=2)),")"),
round(1-mean(outputs2$ep, na.rm=T), digits=4), paste0("(", as.character(round(sd(1-outputs2$ep, na.rm=T), digits=4)),")"),
round(mean(outputs2$U, na.rm=T)-outside_option, digits=2), paste0("(", as.character(round(sd(outputs2$U, na.rm=T), digits=2)),")"),
round(mean(outputs2$V, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs2$V, na.rm=T), digits=2)),")"),
round(mean(outputs2$welfare, na.rm=T), digits=2), paste0("(", as.character(round(sd(outputs2$welfare, na.rm=T), digits=2)),")"))
)
#######################################################################################
##################### Load in Survey Data and Create Tables ######################
#######################################################################################
#read data with actual outcomes
data_survey <- read.csv("~/Dropbox/Matatu/model/greg/sims/table_data2.csv") %>%
mutate(profit = income - repaircost/2, #try and account for some of repair costs already being baked in to income get correct mean levels
salary = salary + 4) #account for makanga salary (approx 400)
##Add Observed results to prediction table
#For baseline data, collapse down to did or pid where appropriate
data_survey_did <- data_survey %>% group_by(did) %>%
summarise(valueofjob=mean(valueofjob, na.rm=T))
#Reg daily outcomes on constant but cluster responses by pid, grab standard error for table
cluster_mean_stder <- function(var) {
reg <- felm(var ~ 1 | 0 | 0 | pid, data=data_survey)
cl_stder <- reg$cse
return(cl_stder)
}
temp <- as.data.frame(t(apply(data_survey, 2, FUN=cluster_mean_stder)))
survey_table <- data.frame(Observed=c(round(mean(data_survey$target, na.rm=T), digits=2), paste0("(", as.character(round(temp$target[1], digits=2)),")"),
round(mean(data_survey$profit, na.rm=T), digits=2), paste0("(", as.character(round(temp$profit[1], digits=2)),")"),
round(mean(data_survey$salary, na.rm=T), digits=2), paste0("(", as.character(round(temp$salary[1], digits=2)),")"),
round(mean(data_survey$separated_2, na.rm=T), digits=4), paste0("(", as.character(round(temp$separated_2[1], digits=4)),")"),
round(mean(data_survey_did$valueofjob, na.rm=T), digits=2), paste0("(", as.character(round(sd(data_survey_did$valueofjob, na.rm=T)/sqrt(nrow(data_survey_did)), digits=2)),")"),
"---", "",
"---", ""))
View(survey_table)
#read data with actual outcomes
data_survey <- read.csv("~/Dropbox/Matatu/model/greg/sims/table_data2.csv") %>%
mutate(profit = (income - repaircost/2)/100, #try and account for some of repair costs already being baked in to income get correct mean levels
(salary = salary + 4)/100, #account for makanga salary (approx 400)
target = target/100,
valueofjob = valueofjob/100) #make sure winsorized
##Add Observed results to prediction table
#For baseline data, collapse down to did or pid where appropriate
data_survey_did <- data_survey %>% group_by(did) %>%
summarise(valueofjob=mean(valueofjob, na.rm=T))
#Reg daily outcomes on constant but cluster responses by pid, grab standard error for table
cluster_mean_stder <- function(var) {
reg <- felm(var ~ 1 | 0 | 0 | pid, data=data_survey)
cl_stder <- reg$cse
return(cl_stder)
}
temp <- as.data.frame(t(apply(data_survey, 2, FUN=cluster_mean_stder)))
survey_table <- data.frame(Observed=c(round(mean(data_survey$target, na.rm=T), digits=2), paste0("(", as.character(round(temp$target[1], digits=2)),")"),
round(mean(data_survey$profit, na.rm=T), digits=2), paste0("(", as.character(round(temp$profit[1], digits=2)),")"),
round(mean(data_survey$salary, na.rm=T), digits=2), paste0("(", as.character(round(temp$salary[1], digits=2)),")"),
round(mean(data_survey$separated_2, na.rm=T), digits=4), paste0("(", as.character(round(temp$separated_2[1], digits=4)),")"),
round(mean(data_survey_did$valueofjob, na.rm=T), digits=2), paste0("(", as.character(round(sd(data_survey_did$valueofjob, na.rm=T)/sqrt(nrow(data_survey_did)), digits=2)),")"),
"---", "",
"---", ""))
#Calc differences (with standard error)
diffs <- data.frame(Difference = c(
round(mean(outputs$target, na.rm=T)-mean(data_survey$target, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$target, na.rm=T)^2 + temp$target[1]^2),digits=2),")"),
round(mean(outputs$exp_profit, na.rm=T)-mean(data_survey$profit, na.rm=T), digits=3),
paste0("(",round(sqrt(sd(outputs$exp_profit, na.rm=T)^2 + temp$profit[1]^2),digits=2),")"),
round(mean(outputs$exp_salary, na.rm=T)-mean(data_survey$salary, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$exp_salary, na.rm=T)^2 + temp$salary[1]^2),digits=2),")"),
round(mean(1-outputs$ep, na.rm=T)-mean(data_survey$separated_2, na.rm=T), digits=4),
paste0("(",round(sqrt(sd(outputs$ep, na.rm=T)^2 + temp$separated_2[1]^2),digits=4),")"),
round(round(mean(outputs$U, na.rm=T)-outside_option, digits=2)-mean(data_survey_did$valueofjob, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$U, na.rm=T)^2 + (sd(data_survey_did$valueofjob, na.rm=T)/sqrt(nrow(data_survey_did)))^2),digits=2),")"),
"---",
"",
"---",
""
))
#Col bind for Status Quo Match
out_table <- bind_cols(table, survey_table, diffs)
options(huxtable.print = print_latex)
tbl <- hux(out_table)
tbl
tbl<- print.xtable(xtable(out_table,
caption=c("Prediction Results Versus Data"),
align=c("l","p{9cm}","c","c","c")),
include.rownames=FALSE,
caption.placement = getOption("xtable.caption.placement", "top"),
latex.environments = getOption("xtable.latex.environments", c("center")),
hline.after=c(-1,-1,0,nrow(table),nrow(table)),
add.to.row=list(pos=list(2,4,6,8,10,12), command=c("[.5em]","[.5em]","[.5em]","[.5em]","[.5em]","[.5em]"))
)
cat(tbl, sep = '\n', file="~/Dropbox/Matatu/model/greg/sims/tables/compare_table1.tex")
#read data with actual outcomes
data_survey <- read.csv("~/Dropbox/Matatu/model/greg/sims/table_data2.csv") %>%
mutate(profit = (income - repaircost/2)/100, #try and account for some of repair costs already being baked in to income get correct mean levels
(salary = salary + 400)/100, #account for makanga salary (approx 400)
target = target/100,
valueofjob = valueofjob/100) #make sure winsorized
##Add Observed results to prediction table
#For baseline data, collapse down to did or pid where appropriate
data_survey_did <- data_survey %>% group_by(did) %>%
summarise(valueofjob=mean(valueofjob, na.rm=T))
#Reg daily outcomes on constant but cluster responses by pid, grab standard error for table
cluster_mean_stder <- function(var) {
reg <- felm(var ~ 1 | 0 | 0 | pid, data=data_survey)
cl_stder <- reg$cse
return(cl_stder)
}
temp <- as.data.frame(t(apply(data_survey, 2, FUN=cluster_mean_stder)))
survey_table <- data.frame(Observed=c(round(mean(data_survey$target, na.rm=T), digits=2), paste0("(", as.character(round(temp$target[1], digits=2)),")"),
round(mean(data_survey$profit, na.rm=T), digits=2), paste0("(", as.character(round(temp$profit[1], digits=2)),")"),
round(mean(data_survey$salary, na.rm=T), digits=2), paste0("(", as.character(round(temp$salary[1], digits=2)),")"),
round(mean(data_survey$separated_2, na.rm=T), digits=4), paste0("(", as.character(round(temp$separated_2[1], digits=4)),")"),
round(mean(data_survey_did$valueofjob, na.rm=T), digits=2), paste0("(", as.character(round(sd(data_survey_did$valueofjob, na.rm=T)/sqrt(nrow(data_survey_did)), digits=2)),")"),
"---", "",
"---", ""))
#Calc differences (with standard error)
diffs <- data.frame(Difference = c(
round(mean(outputs$target, na.rm=T)-mean(data_survey$target, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$target, na.rm=T)^2 + temp$target[1]^2),digits=2),")"),
round(mean(outputs$exp_profit, na.rm=T)-mean(data_survey$profit, na.rm=T), digits=3),
paste0("(",round(sqrt(sd(outputs$exp_profit, na.rm=T)^2 + temp$profit[1]^2),digits=2),")"),
round(mean(outputs$exp_salary, na.rm=T)-mean(data_survey$salary, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$exp_salary, na.rm=T)^2 + temp$salary[1]^2),digits=2),")"),
round(mean(1-outputs$ep, na.rm=T)-mean(data_survey$separated_2, na.rm=T), digits=4),
paste0("(",round(sqrt(sd(outputs$ep, na.rm=T)^2 + temp$separated_2[1]^2),digits=4),")"),
round(round(mean(outputs$U, na.rm=T)-outside_option, digits=2)-mean(data_survey_did$valueofjob, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$U, na.rm=T)^2 + (sd(data_survey_did$valueofjob, na.rm=T)/sqrt(nrow(data_survey_did)))^2),digits=2),")"),
"---",
"",
"---",
""
))
#Col bind for Status Quo Match
out_table <- bind_cols(table, survey_table, diffs)
options(huxtable.print = print_latex)
tbl <- hux(out_table)
tbl
tbl<- print.xtable(xtable(out_table,
caption=c("Prediction Results Versus Data"),
align=c("l","p{9cm}","c","c","c")),
include.rownames=FALSE,
caption.placement = getOption("xtable.caption.placement", "top"),
latex.environments = getOption("xtable.latex.environments", c("center")),
hline.after=c(-1,-1,0,nrow(table),nrow(table)),
add.to.row=list(pos=list(2,4,6,8,10,12), command=c("[.5em]","[.5em]","[.5em]","[.5em]","[.5em]","[.5em]"))
)
cat(tbl, sep = '\n', file="~/Dropbox/Matatu/model/greg/sims/tables/compare_table1.tex")
#read data with actual outcomes
data_survey <- read.csv("~/Dropbox/Matatu/model/greg/sims/table_data2.csv") %>%
mutate(profit = (income - repaircost/2)/100, #try and account for some of repair costs already being baked in to income get correct mean levels
(salary = salary + 400)/100, #account for makanga salary (approx 400)
target = target/100,
valueofjob = valueofjob/100) #make sure winsorized
summary(data_survey)
#read data with actual outcomes
data_survey <- read.csv("~/Dropbox/Matatu/model/greg/sims/table_data2.csv") %>%
mutate(profit = (income - repaircost/2)/100, #try and account for some of repair costs already being baked in to income get correct mean levels
salary = (salary + 400)/100, #account for makanga salary (approx 400)
target = target/100,
valueofjob = valueofjob/100) #make sure winsorized
##Add Observed results to prediction table
#For baseline data, collapse down to did or pid where appropriate
data_survey_did <- data_survey %>% group_by(did) %>%
summarise(valueofjob=mean(valueofjob, na.rm=T))
#Reg daily outcomes on constant but cluster responses by pid, grab standard error for table
cluster_mean_stder <- function(var) {
reg <- felm(var ~ 1 | 0 | 0 | pid, data=data_survey)
cl_stder <- reg$cse
return(cl_stder)
}
temp <- as.data.frame(t(apply(data_survey, 2, FUN=cluster_mean_stder)))
survey_table <- data.frame(Observed=c(round(mean(data_survey$target, na.rm=T), digits=2), paste0("(", as.character(round(temp$target[1], digits=2)),")"),
round(mean(data_survey$profit, na.rm=T), digits=2), paste0("(", as.character(round(temp$profit[1], digits=2)),")"),
round(mean(data_survey$salary, na.rm=T), digits=2), paste0("(", as.character(round(temp$salary[1], digits=2)),")"),
round(mean(data_survey$separated_2, na.rm=T), digits=4), paste0("(", as.character(round(temp$separated_2[1], digits=4)),")"),
round(mean(data_survey_did$valueofjob, na.rm=T), digits=2), paste0("(", as.character(round(sd(data_survey_did$valueofjob, na.rm=T)/sqrt(nrow(data_survey_did)), digits=2)),")"),
"---", "",
"---", ""))
#Calc differences (with standard error)
diffs <- data.frame(Difference = c(
round(mean(outputs$target, na.rm=T)-mean(data_survey$target, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$target, na.rm=T)^2 + temp$target[1]^2),digits=2),")"),
round(mean(outputs$exp_profit, na.rm=T)-mean(data_survey$profit, na.rm=T), digits=3),
paste0("(",round(sqrt(sd(outputs$exp_profit, na.rm=T)^2 + temp$profit[1]^2),digits=2),")"),
round(mean(outputs$exp_salary, na.rm=T)-mean(data_survey$salary, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$exp_salary, na.rm=T)^2 + temp$salary[1]^2),digits=2),")"),
round(mean(1-outputs$ep, na.rm=T)-mean(data_survey$separated_2, na.rm=T), digits=4),
paste0("(",round(sqrt(sd(outputs$ep, na.rm=T)^2 + temp$separated_2[1]^2),digits=4),")"),
round(round(mean(outputs$U, na.rm=T)-outside_option, digits=2)-mean(data_survey_did$valueofjob, na.rm=T), digits=2),
paste0("(",round(sqrt(sd(outputs$U, na.rm=T)^2 + (sd(data_survey_did$valueofjob, na.rm=T)/sqrt(nrow(data_survey_did)))^2),digits=2),")"),
"---",
"",
"---",
""
))
#Col bind for Status Quo Match
out_table <- bind_cols(table, survey_table, diffs)
options(huxtable.print = print_latex)
tbl <- hux(out_table)
tbl
tbl<- print.xtable(xtable(out_table,
caption=c("Prediction Results Versus Data"),
align=c("l","p{9cm}","c","c","c")),
include.rownames=FALSE,
caption.placement = getOption("xtable.caption.placement", "top"),
latex.environments = getOption("xtable.latex.environments", c("center")),
hline.after=c(-1,-1,0,nrow(table),nrow(table)),
add.to.row=list(pos=list(2,4,6,8,10,12), command=c("[.5em]","[.5em]","[.5em]","[.5em]","[.5em]","[.5em]"))
)
cat(tbl, sep = '\n', file="~/Dropbox/Matatu/model/greg/sims/tables/compare_table1.tex")
